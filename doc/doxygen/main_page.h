/**
 * @defgroup lwip lwIP
 *
 * @defgroup infrastructure 基盤
 *
 * @defgroup api API
 * lwIPはプログラムがTCP/IPコードと通信するために使用する次の3つの
 * アプリケーション・プログラム・インターフェース(API)を提供します。
 * - 低レベルの "core" / "callback ", @ref callbackstyle_api
 * - 高レベルの @ref sequential_api
 * - BSDスタイルの @ref socket
 *
 * raw TCP/IPインターフェースはアプリケーションプログラムがTCP/IP
 * コードとよりうまく統合できるようにします。プログラムの実行は
 * TCP/IPコードからコールバック関数が呼び出されるイベントベースです。
 * TCP/IPコードとアプリケーションプログラムは同じスレッドで実行されます。
 * シーケンシャルAPIはオーバーヘッドが大きく、アプリケーションに
 * マルチスレッドパラダイムを強制するため、小規模なシステムにはあまり
 * 適していません。
 *
 * raw TCP/IPインターフェースはコード実行時間が速いだけでなく、
 * メモリの消費量も少ないです。欠点は、プログラム開発が多少難しくなる
 * ことと、raw TCP/IPインターフェース用に書かれたアプリケーション
 * プログラムは理解するのが難しくなることです。それでも、コードサイズと
 * メモリ使用量が小さいことが望ましいアプリケーションを書くにはこの方法が
 * 好まれます。
 *
 * すべてのAPIは様々んアプリケーションプログラムで同時に使用することが
 * できます。実際、シーケンシャルAPIはraw TCP/IPインタフェースを使用する
 * アプリケーションプログラムとして実装されています。
 *
 * lwIPのraw APIとraw イーサネットやIPソケットと混同しないでください。
 * 前者はlwIPのネットワークスタック(TCPとUDPを含む)をインタフェースする
 * 方法であり、後者はTCPコネクションやUDPパケットの代わりにraw Ethernetや
 * IPデータを処理することを指します。
 *
 * raw APIアプリケーションはブロックされません。すべてのパケット処理
 * （入力と出力）とタイマー処理（主にTCP）が単一の実行コンテキストで
 * 行われるからです。
 *
 * @defgroup callbackstyle_api "raw" API
 * @ingroup api
 * 非スレッドセーフのAPIです。コールバックスタイルであり最大限の
 * パフォーマンスと最小限のメモリ・フットプリントを実現します。
 * プログラムの実行はコールバック関数によって駆動され、そのアプリ
 * ケーションに関連するアクティビティが発生した場合にlwIPコアに
 * よって呼び出されます。特定のアプリケーションを利用可能な受信データ、
 * 送信データ、エラー通知、ポーリングタイマーの満了、コネクションの
 * クローズなどのイベントに対してコールバック関数を介して通知される
 * ように登録することができます。アプリケーションはこれらのイベントの
 * いずれかまたはすべてに対して処理を実行するコールバック関数を提供する
 * ことができます。各コールバック関数はTCP/IPコード内から呼び出される
 * 通常のC関数です。すべてのコールバック関数には現在のTCPまたはUDPコネクションの
 * 状態を引数として渡されます。また、プログラム固有の状態を保持できる
 * ようにするために、コールバック関数はTCP/IPの状態とは独立したプログラム
 * 固有のの引数で呼び出されます。
 * raw API（ネイティブAPIと呼ばれることもあります）はオペレーティング
 * システムなしで使用できるように設計されたゼロコピー送受信を実装する
 * イベント駆動型のAPIです。このAPIは様々なプロトコル間で相互作用する
 * コアスタックでも使用されます。これはオペレーティングシステムなしで
 * lwIPを実行す際に利用可能な唯一のAPIです。
 *
 * @defgroup sequential_api シーケンシャルAPI
 * @ingroup api
 * シーケンシャルスタイルのAPIで、ブロッキング関数です。オーバーヘッドは
 * 大きいですがTCPIPスレッド以外の任意のスレッドからも呼び出すことができます。
 * シーケンシャルAPIは通常のシーケンシャルなプログラムがlwIPスタックを使用する
 * 方法を提供します。これはBSDのソケットAPIによく似ています。実行モデルは
 * ブロッキングなオープン-リード-ライト-クローズパラダイムに基づいています。
 * TCP/IPスタックはもともとイベントベースなので、TCP/IPコードとアプリケーション
 * プログラムは異なる実行コンテキスト（スレッド）に存在しなければなりません。
 *
 * @defgroup socket ソケットAPI
 * @ingroup api
 * TCPIP以外のスレッドからのみ呼び出されるスレッドセーフなAPIです。<br>
 * @ref LWIP_SOCKET を1に定義することによりアクティベイトすることが
 * できます。<br>
 * ヘッダーは posix/sys/socket.h にります。<br>
 * ソケットAPIは既存のアプリケーションのための互換APIであり、現在は
 * シーケンシャルAPIの上に構築されています。これは他のプラットフォーム
 * （unixやWindowsなど）で稼働しているソケットAPIのアプリケーションを
 * 実行するために必要なすべての関数を提供していることを意味します。
 * しかし、このAPIの使用の限界により既存のプログラムを少しだけ修正する
 * 必要がある非互換性があるかもしれません。
 *
 * @defgroup netifs NETIF
 *
 * @defgroup apps アプリケーション
 */

/**
 * @mainpage 概要
 * @verbinclude "README"
 */

/**
 * @page upgrading 更新履歴
 * @verbinclude "UPGRADING"
 */

/**
 * @page changelog 変更履歴
 *
 * 2.1.0
 * -----
 * * 新しい @ref altcp_api 接続APIでTLSをサポート(https, smtps, mqtt over TLS)
 * * メインビルドシステムを cmake に変更（Makefileファイルリストも今のところ維持されている）
 * * IPv6 サポートの改善: アドレススコープのサポート、ステートレス DHCPv6 のサポート、バグの修正
 * * スレッド/ロッキング要件が満たされていることを保証するためのデバッグヘルパー asserts の追加
 * * sys_mbox_trypost_fromisr()とtcpip_callbackmsg_trycallback_fromisr() の追加 (主に FreeRTOS用)
 * * ソケットAPI: poll()、sendmsg()、recvmsg()をサポート; close時の問題を解決
 *
 * 詳細な変更履歴
 * ------------------
 * @verbinclude "CHANGELOG"
 */

/**
 * @page contrib lwIPに貢献するには
 * @verbinclude "contrib.txt"
 */

/**
 * @page cmake CMakeビルドシステム
 * @verbinclude "BUILDING"
 */

/**
 * @page pitfalls よくある落とし穴
 *
 * lwIPコード内の複数の実行コンテキスト
 * ========================================
 *
 * lwIPの問題の最も一般的な原因はlwIPコード内に複数の実行コンテキストがあることです。
 *
 * lwIPは次の2つの基本的なモードで使用することができます: @ref lwip_nosys モード
 * （ターゲットシステム上で稼働するOS/RTOSが存在しない）と @ref lwip_os モード
 * （ターゲットシステム上で稼働するOSが存在）。
 *
 * 以下も参照のこと: @ref multithreading (特に @ref LWIP_ASSERT_CORE_LOCKED() の部分)
 *
 * メインループモード
 * -------------------
 * メインループモードでは @ref callbackstyle_api しか使用できません。
 * ユーザはlwIP内に1つの実行コンテキストしかないことを保証するために
 * 次の2つの選択肢があります。
 *
 * 1) 割り込み内でnetif->inputを直接呼び出すことにより割り込みコンテキストで
 *    RXイーサネットパケットをlwIPに直接配信します。これはすべてのlwIPコール
 *    バック関数がIRQコンテキストで呼び出されることを意味し、アプリケーション
 *    コードで次のようなさらなる問題を引き起こす可能性があります: IRQが長時間
 *    ブロックされる、アプリケーションコードに複数の実行コンテキストがある、
 *    などです。アプリケーションがlwIPを呼び出したい場合は呼び出し中に割り込みを
 *    無効にする必要があります。タイマーが関係している場合は、タイマーIRQと
 *    イーサネットIRQを互いにロックアウトするために（ネストする可能性がある
 *    ことを考慮した）さらなるロックコードが必要になります。
 *
 * 2) lwIPをメインループで実行する。 @ref lwip_nosys にサンプルコードがあります。
 *    ここではlwIPはメインループのコールスタックからのみ呼び出されます。
 *    イーサネットIRQは受信したテレグラムをメインループでポーリングされるキューに
 *    入れる必要があります。lwPは _決して_ 割り込みから呼び出されないようにする
 *    する必要があります。例えば、SPI IRQ が udp_send() や tcp_write() にデータを
 *    転送したい場合などです。
 *
 * OSモード
 * ---------
 * OSモードでは @ref callbackstyle_api と @ref sequential_api が使用できます。
 * @ref sequential_api はTCPIPスレッド以外のスレッドから呼び出されるように
 * 設計されていますのでここで考慮することはありません。
 * ただし @ref callbackstyle_api の関数はTCPIPスレッドからのみ呼び出されなければ
 * なりません。他のスレッドやIRQコンテキストからこれらの関数を呼び出すのはよくある
 * 間違いです。イーサネットRXはメッセージを送信することによる正しい方法で着信
 * パケットをTCPIPスレッドに配信する必要があり、これはtcpip_input()で実装されて
 * います。
 * 繰り返しになりますがlwIPが割り込みから呼び出されることがないようにしてください。
 * 例えば、SPI IRQがudp_send()やtcp_write()にデータを転送したい場合などです。
 *
 * 1) tcpip_callback()はTCPIPスレッドからコールバックされるために使うことができます。
 *    そこから任意の @ref callbackstyle_api を呼び出すことは安全です。
 *
 * 2) @ref LWIP_TCPIP_CORE_LOCKING を使用してください。すべての @ref callbackstyle_api
 *    関数はlwIPコアロックが取得されたら呼び出すことができます。 @ref LOCK_TCPIP_CORE() と
 *    @ref UNLOCK_TCPIP_CORE() を参照）。
 *    これらのマクロは、割り込みコンテキストでは使用できません。
 *    OSはこのために優先度の反転を正しく処理する必要があります。
 *
 * キャッシュ / DMAの問題
 * =======================
 *
 * DMA可能なethernetハードウェアと零コピーRX
 * ----------------------------------------------
 *
 * lwIPはTCPコードパスで受診したpbufのコンテンツを変更します。
 * これはRX pbufの1つ以上のキャッシュラインがダーティになり、
 * 次のテレグラムを受信するためにはDMAイーサネットハードウェアに
 * メモリが引き渡される前にフラッシュする必要があることを意味します。
 * 詳細な説明については、http://lists.nongnu.org/archive/html/lwip-devel/2017-12/msg00070.html を
 * 参照してください。
 * また、ユーザアプリケーションもpbufに書き込む可能性があるため、
 * バッファをDMAハードウェアに渡す前にデータキャッシュをフラッシュ
 * しないのは一般的にバグであることに注意してください。
 *
 * DMA可能なethernetハードウェアとキャッシュラインアライメント
 * -----------------------------------------------------------
 * 次はDMA可能なハードウェアとバッファ処理に関する素晴らしい記述です。
 * http://www.pebblebay.com/a-guide-to-using-direct-memory-access-in-embedded-systems-part-two/
 * 特に「キャッシュコヒーレンシ」と「バッファアライメント」のセクションを読んでください。
 */

/**
 * @page mem_err メモリプールサイズのデバッグ
 * メモリプールを使用していてlwIPに問題がある場合は、プールのサイズが
 * 正しいものかをチェックしてください。
 * プールのサイズをデバッグするには、\#define LWIP_STATS と
 * \#define MEMP_STATS に 1 を設定してください。デバッガを使用して
 * グローバル変数 lwip_stats.memp[] をチェックしてください。プールの
 * "err" メンバが 0より大きい場合はプールのサイズが小さすぎる可能性が
 * ありますのでサイズを大きくする必要があります。
 */

/**
 * @page bugs バグの報告
 * savannahにあるlwIPバグトラッカーにバグを報告してください。<br>
 * 報告の前にはバグがすでに報告されていないか確認してください。<br>
 * https://savannah.nongnu.org/bugs/?group=lwip
 */

/**
 * @page zerocopyrx 零コピーRX
 * 以下はゼロコピーRXイーサネットドライバのサンプルコードです:
 * @include ZeroCopyRx.c
 */

/**
 * @defgroup lwip_nosys メインループモード ("NO_SYS")
 * @ingroup lwip
 * システムでOSを実行しない場合は \#define NO_SYS 1 を設定して
 * このモードを使用してください。
 * 着信パケットを取り込むには割り込みコンテキストからではなく
 * メインループから netif->input(pbuf, netif) 関数を実行してください。
 * 割り込みコンテキストで @ref pbuf を割り当て、メインループで処理される
 * キューに挿入することができます。<br>
 * メインループで sys_check_timeouts() を定期的に呼び出してください、<br>
 * ポーティング: @ref sys_time, @ref sys_prot, @ref compiler_abstraction の
 * すべての関数を実装してください。<br>
 * このモードでは @ref callbackstyle_api だけを使用することができます。<br>
 * サンプルコード:
 * @include NO_SYS_SampleCode.c
 */

/**
 * @defgroup lwip_os OSモード (TCPIPスレッド)
 * @ingroup lwip
 * システムでOSを実行する場合はこのモードを使用してください。
 * 優先順位の逆転をたさ敷く処理するにはRTOSの使用を、そして、
 * @ref LWIP_TCPIP_CORE_LOCKING を使用することを推奨します。<br>
 * ポーティング: @ref sys_layer のすべての関数を実装してください。<br>
 * @ref tcpip_callback と共に @ref callbackstyle_api を、またすべての
 * @ref sequential_api を使用することができます。
 */

/**
 * @page sys_init システムの初期化
lwIPスタックを初期化するための本当に完全かつ汎用的なシーケンスを示すことは
できません。各自のランタイム環境（例えばタイマー）のための追加的な初期化に
依存するからです。

raw APIを使用する場合、どのように進めるかについてのいくつかのアイデアを
提供することはできます。ここでは、1つのイーサネットnetif、UDPとTCPの
トランスポート層、IPv4とDHCPクライアントを使用する構成を想定します。

以下の関数を出現順に呼び出してください。

- lwip_init()： lwIPスタックとそのすべてのサブシステムを初期化します。

- netif_add(struct netif *netif, ...)：
  使用するネットワークインタフェースをnetif_listに追加します。netif構造体を
  割り当て、この構造体へのポインタを最初の引数として渡します。
  DHCPを使用する場合はクリアされたip_addr構造体へのポインタを渡し、
  そうでない場合は適切な数値を設定してください。状態ポインタはNULLで
  構いません。

  init関数ポインタはイーサネットnetifインタフェースの初期化関数を
  指していなければなりません。次のコードはその使用例を示しています。

@code{.c}
  err_t netif_if_init(struct netif *netif)
  {
    u8_t i;

    for (i = 0; i < ETHARP_HWADDR_LEN; i++) {
      netif->hwaddr[i] = some_eth_addr[i];
    }
    init_my_eth_device();
    return ERR_OK;
  }
@endcode

  イーサネットドライバの場合、入力関数ポインタは "netif/etharp.h "で宣言されている
  lwIP関数 ethernet_input()を指していなければなりません。その他のドライバは
  "lwip/ip.h" で宣言されている ip_input() を使用する必要があります。

- netif_set_default(struct netif *netif)
  デフォルトのネットワークインターフェースを登録します。

- netif_set_link_up(struct netif *netif)
  これはハードウェアのリンク状態です。例えば、有線イーサネットインターフェイスに
  ケーブルが接続されているかなどです。この関数は現在の状態がわからない場合でも
  呼び出す必要があります。リンクアップとリンクダウンのイベントを持つことは
  オプションですが、DHCPとIPv6のディスカバリーにはこれらのイベントの恩恵を受けます。

- netif_set_up(struct netif *netif)
  これはnetifの管理上の（= ソフトウェア的な）状態であり、
  netifを完全に構成した際にこの関数を呼び出す必要があります。

- dhcp_start(struct netif *netif)
  最初の呼び出しでこのインタフェース用の新しいDHCPクライアントを作成してください。
  実際のDHCPステータスについてはnetif->dhcp structで覗くことができます。

- sys_check_timeouts()
  システムの動作中はスタック内のすべてのプロトコル用のすべてのタイマーを
  処理する sys_check_timeouts() を定期的に呼び出す必要があります。この関数を
  マインループまたはそれに相当するものに追加してください。

 */

/**
 * @page multithreading マルチスレッド
 * lwIPはシングルスレッド環境をターゲットとしてスタートしました。マルチ
 * スレッドのサポートを追加する際、コアをスレッドセーフにするのではなく
 * 別のアプローチが選択されました。lwIPコアを実行する１つのメインスレッド
 * （"tcpip_thread"としても知られ地ます）を持つことにしたのです。マルチ
 * スレッド環境で実行する場合、raw API関数はコアスレッドからしか呼び出しては
 * いけません。raw API関数は（pbuf管理関数とメモリ管理関数を除いて）
 * 並列アクセスからは保護されないからです。シーケンシャルAPIまたはソケット
 * APIを使用するアプリケーションスレッドはメッセージパッシングを通じて
 * このメインスレッドと通信します。
 *
 * そのため、他のスレッドやISRから呼び出すことができる関数のリストは非常に
 * 限られています。いかに示すAPIヘッダーファイルにある関数だけがスレッド
 * セーフです。
 * - api.h
 * - netbuf.h
 * - netdb.h
 * - netifapi.h
 * - pppapi.h
 * - sockets.h
 * - sys.h
 *
 * さらに、メモリ（デ）アロケーション関数は @ref SYS_LIGHTWEIGHT_PROT や
 * セマフォで保護されているため、NO_SYS=0 で複数のスレッドから呼び出す
 * ことができます（ISRではできません。
 *
 * Netconn または Socket API関数はコアスレッドに対してスレッドセーフですが
 * 制御ブロックの粒度レベルではリエントラントではありません。つまり、
 * UDP または TCP 制御ブロックは適切なロックなしでは複数のスレッド間で
 * 共有してはいけません。
 *
 * @ref SYS_LIGHTWEIGHT_PROT が 1 に設定され、かつ、
 * @ref LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT が 1 に設定されている場合、
 * pbuf_free() は別のスレッドまたはISRから呼び出すことができます
 * （その場合のみ、PBUF_RAM 用の mem_free を ISR から呼び出すことができます。
 * それ以外の場合、HEAP はセマフォによってしか保護されません)。
 *
 * スレッド処理を正しく行う方法
 * -------------------------------
 *
 * マルチスレッドを使用するアプリケーションでは LWIP_ASSERT_CORE_LOCKED()
 * マクロを実装することを強く推奨します。lwIPコードには正しいスレッド
 * コンテキストのチェックが実装されている場所がいくつかあり、これはユーザが
 * スレッド処理を正しく行うための大きな助けとなります。lwIP/contrib
 * サブディレクトリのunixポートとWin32ポートにあるサンプルコードファイル
 * sys_arch.c を参照してください。
 *
 * 要約すると、sys_mark_tcpip_thread()とsys_check_core_locking() の両関数を
 * あなたのポートにコピーし、あなたのOSで動作するように変更してください。
 * そして、 @ref LWIP_ASSERT_CORE_LOCKED() と @ref LWIP_MARK_TCPIP_THREAD() が
 * これらの関数を指すようにしてください。
 *
 * @ref LWIP_TCPIP_CORE_LOCKING を使用する場合は、sys_lock_tcpip_core()と
 * sys_unlock_tcpip_core()NO両関数もコピーして修正させる必要があります。
 * @ref LOCK_TCPIP_CORE() と @ref UNLOCK_TCPIP_CORE()がこれらの関数を指す
 * ようにしてください。
 */

/**
 * @page optimization 最適化のヒント
最初に最適化したいのは src/core/inet.c にある lwip_standard_checksum()
関数です。この標準関数は \#define LWIP_CHKSUM your_checksum_routine() で
オーバーライドすることができます。

inet.cにC言語による例がありますし、アセンブリ関数を作成することもできます。
RFC1071はこのテーマについての良い入門書です。

リトルエンディアンのアーキテクチャを使用している場合は htons()とhtonl()を
アセンブリまたはインラインで置き換えることで大幅な改善が可能です。
\#define lwip_htons(x) your_htons()
\#define lwip_htonl(x) your_htonl()
これらの \#define をhtons()とhtonl()に定義する場合、lwIPがhtonx/ntohx互換マクロを
定義しないように \#define LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS を定義するべきです。

ネットワークインタフェースドライバが最大ワイヤ速度よりも高速で読み込んでいないか
確認してください。ハードウェアのサービスが頻繁に、かつ十分な速度で行われない場合、
バッファオーバーフローが発生する可能性が高くなります。

例えば、cs8900ドライバを使用している場合はできるだけ頻繁にcs8900if_service(ethif)を
呼び出してください。RTOSを使用している場合は、cs8900割り込みでバイナリセマフォまたは
イベントフラグを使用したドライバをサービスする優先度の高いタスクを起床させてください。
ドライバによってはアプリケーションやネットワークに合わせてチューニングできるものもあります。

製品リリースでは LWIP_STATS を0に設定することを推奨します。メモリオプションに高い値を
設定するだけでは速度性能にはあまり影響しないことに注意してください。
 */
